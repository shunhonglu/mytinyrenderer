struct GouraudShader : public IShader {
    GouraudShader(const mat<4, 4, float>& u_M = View * ModelMat,
                  const mat<4, 4, float>& u_MIT = (View * ModelMat).invert_transpose())
        : varying_intensity(Vec3f()), varying_uv(mat<2, 3, float>()), uniform_M(u_M), uniform_MIT(u_MIT) {}

    Vec3f varying_intensity;       // written by vertex shader, read by fragment shader
    mat<2, 3, float> varying_uv;   // same as above
    mat<4, 4, float> uniform_M;    //  View*ModelMat
    mat<4, 4, float> uniform_MIT;  // (View*ModelMat).invert_transpose();

    virtual Vec4f vertex(int iface, int nthvert) {
        varying_uv.set_col(nthvert, model->uv(iface, nthvert));  // read the uv from .obj file

        Vec4f gl_Vertex = embed<4>(model->vert(iface, nthvert));  // read the vertex from .obj file
        gl_Vertex = transformation(gl_Vertex);                    // transform it to screen coordinates

        Vec4f normal = uniform_MIT * toVec4f(model->normal(iface, nthvert), 0.f);
        varying_intensity[nthvert] =
            std::max(0.f, proj<3>(normal).normalize() * light_dir.normalize());  // get diffuse lighting intensity
        return gl_Vertex;
    }

    virtual bool fragment(Vec3f bar, TGAColor& color) {
        float sum = bar[0] + bar[1] + bar[2];
        float intensity = varying_intensity * bar / sum;  // interpolate intensity for the current pixel
        Vec2f uv = varying_uv * bar / sum;                // interpolate uv for the current pixel
        if (intensity < 1e-2) {
            return true;
        }
        color = model->diffuse(uv) * intensity;  // well duh
        return false;                            // no, we do not discard this pixel
    }
};

struct BumpShader : public IShader {
    BumpShader(const mat<4, 4, float>& u_M = View * ModelMat,
               const mat<4, 4, float>& u_MIT = (View * ModelMat).invert_transpose())
        : varying_uv(mat<2, 3, float>()), uniform_M(u_M), uniform_MIT(u_MIT) {}

    mat<2, 3, float> varying_uv;   // same as above
    mat<4, 4, float> uniform_M;    //  Projection*ModelView
    mat<4, 4, float> uniform_MIT;  // (Projection*ModelView).invert_transpose()

    virtual Vec4f vertex(int iface, int nthvert) {
        varying_uv.set_col(nthvert, model->uv(iface, nthvert));

        Vec4f gl_Vertex = embed<4>(model->vert(iface, nthvert));  // read the vertex from .obj file
        gl_Vertex = transformation(gl_Vertex);                    // transform it to screen coordinates
        return gl_Vertex;
    }

    virtual bool fragment(Vec3f bar, TGAColor& color) {
        float sum = bar[0] + bar[1] + bar[2];
        Vec2f uv = varying_uv * bar / sum;  // interpolate uv for the current pixel

        Vec4f normal = uniform_MIT * toVec4f(model->normal(uv), 0.f);
        Vec3f n = proj<3>(normal).normalize();
        Vec3f l = light_dir.normalize();
        float intensity = std::max(0.f, n * l);
        color = model->diffuse(uv) * intensity;  // well duh
        return false;                            // no, we do not discard this pixel
    }
};
